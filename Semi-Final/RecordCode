import serial
import csv
import time
from pynput import keyboard
import sys
import os                                                                    
import subprocess

#

# CONFIGURATION

SERIAL_PORT = '/dev/cu.SLAB_USBtoUART' # Change this if needed
BAUD_RATE = 115200

# NEW WORD LABELS
WORDS = {
    'reference': 'vv-reference.csv',
    'hi': 'vv-hi.csv',
    'thik': 'vv-thik.csv',
    'hu': 'vv-hu.csv',
    'haan': 'vv-haan.csv',
    'khana': 'vv-khana.csv',
    'hai': 'vv-hai.csv',
    'poha': 'vv-poha.csv',
    'upma': 'vv-upma.csv'
}
# Create directories
BASE_DIR = "data"
for label in WORDS:
    os.makedirs(os.path.join(BASE_DIR, label), exist_ok=True)

HEADER = ['MAV', 'RMS', 'ZC', 'SSC', 'WL', 'rawPeak']


# SERIAL CONNECTION

try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
    time.sleep(2)
    ser.flushInput()
    print(f"Connected to {SERIAL_PORT} at {BAUD_RATE} baud.")
except Exception as e:
    print(f"Error connecting to serial port: {e}")
    sys.exit(1)


# CSV FILE SETUP

csv_writers = {}
csv_files = {}

for label, filename in WORDS.items():
    filepath = os.path.join(BASE_DIR, label, filename)
    f = open(filepath, 'a', newline='')
    writer = csv.writer(f)

# Write header if new file
    if f.tell() == 0:
        writer.writerow(HEADER)

    csv_files[label] = f
    csv_writers[label] = writer

print("\n--- EMG WORD LOGGER ---")
print("Hold SPACE → record REFERENCE")
print("Hold H → hi")
print("Hold T → thik")
print("Hold U → hu")
print("Hold A → haan")
print("Hold K → khana")
print("Hold I → hai")
print("Hold P → poha")
print("Hold M → upma")
print("Press Q → quit\n")

active_label = None
running = True


# READ FROM SERIAL

def read_data():
    line = ser.readline().decode(errors='ignore').strip()
    if not line:
        return None

    parts = line.split(',')
    if len(parts) != 7:
        return None

    try:
    # Drop timestamp
        parts = parts[1:]
        return [float(x) for x in parts]
    except:
        return None

def set_label(label):
    global active_label
    active_label = label
    print(f"Recording {label.upper()}")

def clear_label(label):
    global active_label
    if active_label == label:
        active_label = None
        print(f"Stopped {label.upper()} recording")

# KEYBOARD EVENT HANDLERS

def on_press(key):
    global running

    try:
        if key == keyboard.Key.space:
            set_label('reference')
            
        elif key.char.lower() == 'h':
            set_label('hi')

        elif key.char.lower() == 't':
            set_label('thik')

        elif key.char.lower() == 'u':
            set_label('hu')

        elif key.char.lower() == 'a':
            set_label('haan')

        elif key.char.lower() == 'k':
            set_label('khana')

        elif key.char.lower() == 'i':
            set_label('hai')

        elif key.char.lower() == 'p':
            set_label('poha')

        elif key.char.lower() == 'm':
            set_label('upma')

        elif key.char.lower() == 'q':
            print("Quitting...")
            running = False
            return False

    except AttributeError:
        pass


def on_release(key):
    try:
        if key == keyboard.Key.space:
            clear_label('reference')

        elif key.char.lower() == 'h':
            clear_label('hi')

        elif key.char.lower() == 't':
            clear_label('thik')

        elif key.char.lower() == 'u':
            clear_label('hu')

        elif key.char.lower() == 'a':
            clear_label('haan')

        elif key.char.lower() == 'k':
            clear_label('khana')

        elif key.char.lower() == 'i':
            clear_label('hai')

        elif key.char.lower() == 'p':
            clear_label('poha')

        elif key.char.lower() == 'm':
            clear_label('upma')

    except AttributeError:
        pass


# MAIN LOOP

listener = keyboard.Listener(on_press=on_press, on_release=on_release)
listener.start()

try:
    while running:
        data = read_data()
        if data and active_label:
            csv_writers[active_label].writerow(data)
            csv_files[active_label].flush

        time.sleep(0.001)

except KeyboardInterrupt:
    print("\nInterrupted by user.")

finally:
    ser.close()

    for label, f in csv_files.items():
        f.close()
        abs_path = os.path.abspath(f.name)
        print(f"Saved: {label.upper()} → {abs_path}")

    listener.stop()
    print("\nSerial closed. All CSV files saved successfully.")
