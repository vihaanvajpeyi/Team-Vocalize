import serial
import csv
import time
from pynput import keyboard
import sys
import os
import subprocess


# CONFIGURATION

SERIAL_PORT = 'COM21' # Change this if needed
BAUD_RATE = 115200

# NEW WORD LABELS
WORDS = {
    'reference': 'reference.csv',
    'hi': 'hi.csv',
    'thik': 'thik.csv',
    'hu': 'hu.csv',
    'haan': 'haan.csv',
    'khana': 'khana.csv',
    'hai': 'hai.csv',
    'madad': 'madad.csv',
    'chahiye': 'chahiye.csv'
}

# Create directories
BASE_DIR = "data"
for label in WORDS:
    os.makedirs(os.path.join(BASE_DIR, label), exist_ok=True)

HEADER = ['MAV', 'RMS', 'ZC', 'SSC', 'WL', 'rawPeak']


# SERIAL CONNECTION

try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
    time.sleep(2)
    ser.flushInput()
    print(f"Connected to {SERIAL_PORT} at {BAUD_RATE} baud.")
except Exception as e:
    print(f"Error connecting to serial port: {e}")
    sys.exit(1)


# CSV FILE SETUP

csv_writers = {}
csv_files = {}

for label, filename in WORDS.items():
    filepath = os.path.join(BASE_DIR, label, filename)
    f = open(filepath, 'a', newline='')
    writer = csv.writer(f)

# Write header if new file
    if f.tell() == 0:
        writer.writerow(HEADER)

    csv_files[label] = f
    csv_writers[label] = writer

print("\n--- EMG WORD LOGGER ---")
print("Hold SPACE â†’ record REFERENCE")
print("Hold H â†’ hi")
print("Hold T â†’ thik")
print("Hold U â†’ hu")
print("Hold A â†’ haan")
print("Hold K â†’ khana")
print("Hold I â†’ hai")
print("Hold M â†’ madad")
print("Hold C â†’ chahiye")
print("Press Q â†’ quit\n")

active_label = None
running = True


# READ FROM SERIAL

def read_data():
    line = ser.readline().decode(errors='ignore').strip()
    if not line:
        return None

    parts = line.split(',')
    if len(parts) != 7:
        return None

    try:
    # Drop timestamp
        parts = parts[1:]
        return [float(x) for x in parts]
    except:
        return None

def set_label(label):
    global active_label
    active_label = label
    print(f"Recording {label.upper()}")

def clear_label(label):
    global active_label
    if active_label == label:
        active_label = None
        print(f"Stopped {label.upper()} recording")

# KEYBOARD EVENT HANDLERS

def on_press(key):
    global running

    try:
        if key == keyboard.Key.space:
            set_label('reference')
            
        elif key.char.lower() == 'h':
            set_label('hi')

        elif key.char.lower() == 't':
            set_label('thik')
          

        elif key.char.lower() == 'u':
            set_label('hu')
           

        elif key.char.lower() == 'a':
            set_label('haan')
           

        elif key.char.lower() == 'k':
            set_label('khana')
            

        elif key.char.lower() == 'i':
            set_label('hai')
          

        elif key.char.lower() == 'm':
            set_label('madad')
            

        elif key.char.lower() == 'c':
            set_label('chahiye')
        

        elif key.char.lower() == 'q':
            print("Quitting...")
            running = False
            return False

    except AttributeError:
        pass


def on_release(key):
    try:
        if key == keyboard.Key.space:
            clear_label('reference')
          

        elif key.char.lower() == 'h':
            clear_label('hi')
          

        elif key.char.lower() == 't':
            clear_label('thik')
            

        elif key.char.lower() == 'u':
            clear_label('hu')
       

        elif key.char.lower() == 'a':
            clear_label('haan')
          

        elif key.char.lower() == 'k':
            clear_label('khana')
            

        elif key.char.lower() == 'i':
            clear_label('hai')
           

        elif key.char.lower() == 'm':
            clear_label('madad')
           

        elif key.char.lower() == 'c':
            clear_label('chahiye')
           
    except AttributeError:
        pass


# MAIN LOOP

listener = keyboard.Listener(on_press=on_press, on_release=on_release)
listener.start()

try:
    while running:
        data = read_data()
        if data and active_label:
            csv_writers[active_label].writerow(data)
            csv_files[active_label].flush

        time.sleep(0.001)

except KeyboardInterrupt:
    print("\nInterrupted by user.")

finally:
    ser.close()

    for label, f in csv_files.items():
        f.close()
        abs_path = os.path.abspath(f.name)
        print(f"ðŸ’¾ Saved: {label.upper()} â†’ {abs_path}")

    listener.stop()
    print("\nSerial closed. All CSV files saved successfully.")

