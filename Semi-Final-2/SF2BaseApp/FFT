package com.example.vocalizesf2


import kotlin.math.*

object FFT {
    // Compute real FFT: input array length <= nFft (padded zeros), returns interleaved (re, im) size nFft*2
    fun compute(realInput: FloatArray, nFft: Int): FloatArray {
        val complex = FloatArray(nFft * 2)
        val copyLen = min(realInput.size, nFft)
        for (i in 0 until copyLen) {
            complex[2 * i] = realInput[i]
            complex[2 * i + 1] = 0f
        }
        for (i in copyLen until nFft) {
            complex[2 * i] = 0f
            complex[2 * i + 1] = 0f
        }
        fft(complex, nFft)
        return complex
    }

    private fun fft(data: FloatArray, n: Int) {
        val nu = (kotlin.math.ln(n.toDouble()) / kotlin.math.ln(2.0)).toInt()
        var j = 0
        for (i in 0 until n - 1) {
            if (i < j) {
                val ti = data[2 * i]; val tr = data[2 * j]
                data[2 * i] = tr; data[2 * j] = ti
                val tii = data[2 * i + 1]; val trr = data[2 * j + 1]
                data[2 * i + 1] = trr; data[2 * j + 1] = tii
            }
            var k = n / 2
            while (k <= j) {
                j -= k
                k /= 2
            }
            j += k
        }

        var le = 2
        var le2 = 1
        for (l in 1..nu) {
            val ang = Math.PI / le2
            val wR = kotlin.math.cos(ang)
            val wI = -kotlin.math.sin(ang)
            var ur = 1.0
            var ui = 0.0
            var m = 0
            while (m < le2) {
                var i = m
                while (i < n) {
                    val j2 = i + le2
                    val tr = data[2 * j2] * ur - data[2 * j2 + 1] * ui
                    val ti = data[2 * j2] * ui + data[2 * j2 + 1] * ur
                    val qr = data[2 * i]
                    val qi = data[2 * i + 1]
                    data[2 * j2] = (qr - tr).toFloat()
                    data[2 * j2 + 1] = (qi - ti).toFloat()
                    data[2 * i] = (qr + tr).toFloat()
                    data[2 * i + 1] = (qi + ti).toFloat()
                    i += le
                }
                val tmpUr = ur
                ur = tmpUr * wR - ui * wI
                ui = tmpUr * wI + ui * wR
                m++
            }
            le *= 2
            le2 *= 2
        }
    }
}
