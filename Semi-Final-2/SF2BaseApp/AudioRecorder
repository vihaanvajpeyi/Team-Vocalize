package com.example.vocalizesf2

import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import kotlin.concurrent.thread
import kotlin.math.min

class AudioRecorder private constructor(
    private val sampleRate: Int,
    private val durationSec: Double
) {

    companion object {
        @Volatile private var instance: AudioRecorder? = null

        fun getInstance(sampleRate: Int, durationSec: Double): AudioRecorder {
            return instance ?: synchronized(this) {
                instance ?: AudioRecorder(sampleRate, durationSec).also { instance = it }
            }
        }
    }

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private var bufferSize = 0
    private var callback: ((ShortArray) -> Unit)? = null

    fun setOnDataReadyListener(cb: (ShortArray) -> Unit) {
        callback = cb
    }

    /**
     * Only call this AFTER checking RECORD_AUDIO permission.
     * If permission is missing, AudioRecord will crash â€” MainActivity handles permission.
     */
    fun start() {
        if (isRecording) return

        bufferSize = AudioRecord.getMinBufferSize(
            sampleRate,
            AudioFormat.CHANNEL_IN_MONO,
            AudioFormat.ENCODING_PCM_16BIT
        )

        if (bufferSize <= 0) {
            Log.e("VCZ", "AudioRecord ERROR: bufferSize invalid ($bufferSize)")
            return
        }

        audioRecord = try {
            AudioRecord(
                MediaRecorder.AudioSource.MIC,
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                bufferSize
            )
        } catch (e: Exception) {
            Log.e("VCZ", "AudioRecord init failed: ${e.message}")
            return
        }

        try {
            audioRecord?.startRecording()
        } catch (e: Exception) {
            Log.e("VCZ", "AudioRecord startRecording failed: ${e.message}")
            return
        }

        isRecording = true
        Log.d("VCZ", "AudioRecorder started successfully")

        thread {
            val totalSamples = (sampleRate * durationSec).toInt()
            val pcmBuffer = ShortArray(totalSamples)
            var offset = 0

            while (isRecording) {
                val remaining = totalSamples - offset
                val chunk = ShortArray(min(bufferSize, remaining))

                val read = try {
                    audioRecord?.read(chunk, 0, chunk.size) ?: -1
                } catch (e: Exception) {
                    Log.e("VCZ", "AudioRecord read() failed: ${e.message}")
                    break
                }

                if (read > 0) {
                    System.arraycopy(chunk, 0, pcmBuffer, offset, read)
                    offset += read
                }

                if (offset >= totalSamples) {
                    callback?.invoke(pcmBuffer.copyOf())
                    offset = 0
                }
            }
        }
    }

    fun stop() {
        isRecording = false
        try {
            audioRecord?.stop()
        } catch (e: Exception) {
            Log.e("VCZ", "Error stopping AudioRecord: ${e.message}")
        }
        audioRecord?.release()
        audioRecord = null
        Log.d("VCZ", "AudioRecorder stopped")
    }
}
