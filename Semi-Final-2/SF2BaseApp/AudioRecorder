package com.example.vocalizesf2

import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import kotlin.concurrent.thread
import kotlin.math.min

class AudioRecorder private constructor(
    private val sampleRate: Int,
    private val durationSec: Double
) {

    companion object {
        @Volatile private var instance: AudioRecorder? = null

        fun getInstance(sampleRate: Int, durationSec: Double): AudioRecorder {
            return instance ?: synchronized(this) {
                instance ?: AudioRecorder(sampleRate, durationSec).also { instance = it }
            }
        }
    }

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private var callback: ((ShortArray) -> Unit)? = null

    fun setOnDataReadyListener(cb: (ShortArray) -> Unit) {
        callback = cb
    }

    fun start() {
        if (isRecording) return

        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val format = AudioFormat.ENCODING_PCM_16BIT

        val minBuffer = AudioRecord.getMinBufferSize(sampleRate, channelConfig, format)
        if (minBuffer <= 0) {
            Log.e("VCZ", "AudioRecord ERROR: invalid minBuffer=$minBuffer")
            return
        }

        // ðŸ”¥ FIX: Use a MUCH larger buffer to avoid underruns on Bluetooth / Android
        val bufferSize = minBuffer * 4

        Log.d("VCZ", "AudioRecord bufferSize=$bufferSize  (minBuffer=$minBuffer)")

        audioRecord = AudioRecord(
            MediaRecorder.AudioSource.MIC,
            sampleRate,
            channelConfig,
            format,
            bufferSize
        )

        if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
            Log.e("VCZ", "AudioRecord not initialized!")
            return
        }

        try {
            audioRecord?.startRecording()
        } catch (e: Exception) {
            Log.e("VCZ", "startRecording FAILED: ${e.message}")
            return
        }

        isRecording = true
        Log.d("VCZ", "AudioRecorder STARTED")

        thread {
            val totalSamples = (sampleRate * durationSec).toInt() // EXACT 32000 samples
            val captureBuffer = ShortArray(totalSamples)

            while (isRecording) {
                var collected = 0

                while (collected < totalSamples && isRecording) {
                    val read = audioRecord?.read(
                        captureBuffer,
                        collected,
                        totalSamples - collected,
                        AudioRecord.READ_BLOCKING
                    ) ?: -1

                    if (read <= 0) {
                        Log.e("VCZ", "AudioRecord READ ERROR: $read")
                        break
                    }

                    collected += read
                }

                if (collected == totalSamples) {
                    // FULL clean 2 sec PCM batch ready
                    callback?.invoke(captureBuffer.copyOf())
                }
            }
        }
    }

    fun stop() {
        isRecording = false
        try {
            audioRecord?.stop()
        } catch (e: Exception) {
            Log.e("VCZ", "Error stopping AudioRecord: ${e.message}")
        }
        audioRecord?.release()
        audioRecord = null
        Log.d("VCZ", "AudioRecorder STOPPED")
    }
}
