package com.example.vocalizesf2

import android.content.Context
import android.util.Log
import org.tensorflow.lite.Interpreter
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.max
import kotlin.math.min

class TFLiteModel(context: Context) {

    private val interpreter: Interpreter
    private val labels: List<String>
    private val modelInputShape: IntArray
    private val expectedMelBins: Int
    private val expectedTimeFrames: Int
    private val expectedChannels: Int

    init {
        val modelBytes = context.assets.open("model.tflite").readBytes()
        val bb = ByteBuffer.allocateDirect(modelBytes.size).order(ByteOrder.nativeOrder())
        bb.put(modelBytes)
        bb.rewind()

        val options = Interpreter.Options().apply {
            setNumThreads(4)
            setUseXNNPACK(true)
        }
        interpreter = Interpreter(bb, options)

        labels = context.assets.open("labels.txt")
            .bufferedReader()
            .readLines()
            .filter { it.isNotBlank() }

        modelInputShape = interpreter.getInputTensor(0).shape()
        if (modelInputShape.size < 4) throw IllegalStateException("Unexpected model input shape: ${modelInputShape.contentToString()}")
        expectedMelBins = modelInputShape[1]
        expectedTimeFrames = modelInputShape[2]
        expectedChannels = modelInputShape[3]

        Log.d("VCZ", "TFLite loaded. labels=${labels.size}, inputShape=${modelInputShape.contentToString()}")
    }

    fun predict(input: Array<Array<FloatArray>>): String {
        val melBins = input.size
        val timeFrames = if (melBins > 0) input[0].size else 0
        val channels = if (melBins > 0 && timeFrames > 0) input[0][0].size else 1

        Log.d("VCZ", "predict() input melBins=$melBins timeFrames=$timeFrames channels=$channels; model expects melBins=$expectedMelBins timeFrames=$expectedTimeFrames channels=$expectedChannels")

        // Create java-compatible 4D array: float[1][expectedMelBins][expectedTimeFrames][expectedChannels]
        val javaInput = Array(1) {
            Array(expectedMelBins) {
                Array(expectedTimeFrames) {
                    FloatArray(expectedChannels)
                }
            }
        }

        // Center-copy / pad mel -> javaInput
        val melOffsetSrcStart = if (melBins > expectedMelBins) (melBins - expectedMelBins) / 2 else 0
        val melOffsetDstStart = if (expectedMelBins > melBins) (expectedMelBins - melBins) / 2 else 0

        for (mDst in 0 until expectedMelBins) {
            val mSrc = mDst - melOffsetDstStart + melOffsetSrcStart
            val melExists = (mSrc in 0 until melBins)
            val srcTimeFrames = if (melExists) input[mSrc].size else 0
            val timeOffsetSrcStart = if (srcTimeFrames > expectedTimeFrames) (srcTimeFrames - expectedTimeFrames) / 2 else 0
            val timeOffsetDstStart = if (expectedTimeFrames > srcTimeFrames) (expectedTimeFrames - srcTimeFrames) / 2 else 0

            for (tDst in 0 until expectedTimeFrames) {
                val tSrc = tDst - timeOffsetDstStart + timeOffsetSrcStart
                if (melExists && tSrc in 0 until srcTimeFrames) {
                    val srcChannels = input[mSrc][tSrc].size
                    val copyCount = min(srcChannels, expectedChannels)
                    for (c in 0 until copyCount) {
                        javaInput[0][mDst][tDst][c] = input[mSrc][tSrc][c]
                    }
                } else {
                    // zero pad
                }
            }
        }

        val output = Array(1) { FloatArray(labels.size) }
        interpreter.run(javaInput, output)

        val scores = output[0]
        var best = 0
        var bestScore = scores.getOrElse(0) { Float.NEGATIVE_INFINITY }
        for (i in scores.indices) {
            if (scores[i] > bestScore) {
                bestScore = scores[i]
                best = i
            }
        }

        val label = labels.getOrElse(best) { "unknown" }
        Log.d("VCZ", "predict -> $label (score=$bestScore)")
        return label
    }

    fun close() {
        interpreter.close()
    }
}
