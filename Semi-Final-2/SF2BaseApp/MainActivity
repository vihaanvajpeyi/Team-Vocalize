package com.example.vocalizesf2

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.speech.tts.TextToSpeech
import android.util.Log
import android.widget.Button
import android.widget.TextView
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import kotlinx.coroutines.*
import java.util.*

class MainActivity : AppCompatActivity() {

    private lateinit var listenButton: Button
    private lateinit var recognizedText: TextView

    private var recorder: AudioRecorder? = null
    private var model: TFLiteModel? = null
    private var tts: TextToSpeech? = null

    private var isListening = false
    private val uiScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    // --------------------------------------------------------------------
    // PERMISSIONS
    // --------------------------------------------------------------------
    private val requiredPermissions: Array<String>
        get() {
            val arr = mutableListOf(Manifest.permission.RECORD_AUDIO)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                arr.add(Manifest.permission.BLUETOOTH_CONNECT)
                arr.add(Manifest.permission.BLUETOOTH_SCAN)
            }
            return arr.toTypedArray()
        }

    private val permissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { results ->
            val denied = results.filter { !it.value }.keys
            if (denied.isEmpty()) {
                Log.d("VCZ", "All permissions granted")
                startListening()
                return@registerForActivityResult
            }

            val permanentlyDenied = denied.any { perm ->
                !shouldShowRequestPermissionRationale(perm)
            }

            if (permanentlyDenied) {
                AlertDialog.Builder(this)
                    .setTitle("Permission required")
                    .setMessage("Microphone and Bluetooth permissions are required for Vocalize.")
                    .setPositiveButton("Open Settings") { _, _ ->
                        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                        intent.data = Uri.parse("package:$packageName")
                        startActivity(intent)
                    }
                    .setNegativeButton("Cancel", null)
                    .show()
            } else {
                AlertDialog.Builder(this)
                    .setTitle("Permission required")
                    .setMessage("This app needs microphone & Bluetooth to listen. Allow permissions?")
                    .setPositiveButton("Ask again") { _, _ -> requestMissingPermissions() }
                    .setNegativeButton("Cancel", null)
                    .show()
            }
        }

    private fun hasAllPermissions(): Boolean =
        requiredPermissions.all { perm ->
            ContextCompat.checkSelfPermission(this, perm) == PackageManager.PERMISSION_GRANTED
        }

    private fun requestMissingPermissions() {
        val missing = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }.toTypedArray()

        if (missing.isNotEmpty()) permissionLauncher.launch(missing)
    }

    // --------------------------------------------------------------------
    // ON CREATE
    // --------------------------------------------------------------------
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        listenButton = findViewById(R.id.listenButton)
        recognizedText = findViewById(R.id.recognizedText)

        // Load TFLite model
        try {
            model = TFLiteModel(this)
            Log.d("VCZ", "TFLite MODEL loaded successfully")
        } catch (e: Exception) {
            Log.e("VCZ", "Model load FAILED", e)
            recognizedText.text = "Model failed to load"
        }

        // TTS
        tts = TextToSpeech(this) { status ->
            if (status == TextToSpeech.SUCCESS) {
                tts?.language = Locale("hi", "IN")
            }
        }

        // BUTTON
        listenButton.setOnClickListener {
            if (isListening) {
                stopListening()
            } else {
                if (!hasAllPermissions()) {
                    requestMissingPermissions()
                    return@setOnClickListener
                }
                startListening()
            }
        }
    }


    // --------------------------------------------------------------------
    // START LISTENING
    // --------------------------------------------------------------------
    private fun startListening() {
        Log.d("VCZ", "startListening()")

        if (!hasAllPermissions()) {
            requestMissingPermissions()
            return
        }

        // Try Bluetooth SCO (optional, may not work on newer Android)
        try {
            val am = getSystemService(AUDIO_SERVICE) as? android.media.AudioManager
            am?.startBluetoothSco()
            am?.isBluetoothScoOn = true
        } catch (_: Exception) {}

        recorder = AudioRecorder.getInstance(16000, 2.0).also { rec ->

            rec.setOnDataReadyListener { pcm ->

                uiScope.launch(Dispatchers.Default) {
                    try {
                        // FULL CORRECT PREPROCESSING → EXACT SAME AS PYTHON
                        val melBatch = Preprocessing.audioToMelspectrogram(pcm)
                        val mel = melBatch[0]     // [96][201]

                        // FEED DIRECTLY → TFLiteModel handles formatting
                        val predicted = model?.predict(mel) ?: "unknown"

                        Log.d("VCZ", "Predicted = $predicted")

                        withContext(Dispatchers.Main) {

                            // Show it in the UI (optional, you may hide "base" if preferred)
                            recognizedText.text = predicted

                            // If class is "base", do NOT speak anything
                            if (predicted.lowercase() == "base") {
                                Log.d("VCZ", "Silent class detected → no TTS output")
                                // tts?.speak("", TextToSpeech.QUEUE_FLUSH, null, "utt1")  // <-- DON'T speak
                                return@withContext
                            }

                            // Speak for all non-base classes
                            tts?.speak(predicted, TextToSpeech.QUEUE_FLUSH, null, "utt1")
                        }


                    } catch (e: Exception) {
                        Log.e("VCZ", "Inference error", e)
                    }
                }
            }

            rec.start()
        }

        isListening = true
        listenButton.text = "LISTENING..."
    }


    // --------------------------------------------------------------------
    // STOP LISTENING
    // --------------------------------------------------------------------
    private fun stopListening() {
        recorder?.stop()
        recorder = null
        isListening = false
        listenButton.text = "START LISTENING"

        try {
            val am = getSystemService(AUDIO_SERVICE) as? android.media.AudioManager
            am?.stopBluetoothSco()
            am?.isBluetoothScoOn = false
        } catch (_: Exception) {}
    }


    // --------------------------------------------------------------------
    // ON DESTROY
    // --------------------------------------------------------------------
    override fun onDestroy() {
        super.onDestroy()
        recorder?.stop()
        tts?.shutdown()
        model?.close()
        uiScope.cancel()
    }
}
